    Git
Software de control de versiones, lleva el historial de un proyecto
Facilita el desarrollo y mantenimiento de aplicaciones, guardando los cambios sufren los archivos en el tiempo

    Versiones
Lo hace tomando una foto de los archivos, guardando la version con los cambios hechos
Una version es una copia guardada de como está el proyecto cierto momento
La version queda en el registro de git, a cada una la identifica nombrandola con un codigo alfanumerico,
mas una descripcion del cambio hecho, que nosotros agregamos
Así sucesivamente cuando se trabaja en un proyecto, se va guardando una version
por cada vez que los archivos sufren cambios

Gracias a este historial o registro de versiones, se puede volver atras, 
antes de un cambio, en casos que deje de funcionar correctamente, o se desee tomar un rumbo distinto

    Branches
En git se trabaja con ramas que van desprendiendose del repositorio original
Se cuenta con el master, la version en produccion, esta no se toca
De esta sale dev, que es la version de desarrollo, de ella salen las ramas con las que se trabajan
En un grupo de trabajo, para cada programador se desprende una rama, branch o flujo de trabajo

    Merge
El trabajo se reparte, y cada programador genera sus propias versiones del trabajo que le corresponde
mientras avanza, cuando los programadores terminan su parte, se hace el merge
El merge es la fusión de las ramas, que vuelven al dev,
recien cuando se comprueba que el dev funciona correctamente, pasa a produccion

En el proceso del merge, git detecta si mas de un programador está trabajando en la misma parte,
si el mismo archivo sufre cambios por distintos desarrolladores, git avisa de esto y pregunta qué hacer
Para el merge al dev, hay sistemas de integración continua, que aplican tests automatizados, que detectan fallos

Copia del repositorio en remoto, origin

---
Trabajando con git bash:

    Crear repositorio
Creamos la carpeta de nuestro proyecto, con sus archivos

Si para nuestro proyecto queremos seguimiento de todos los archivos o parte, y poder hacer respaldos de ellos,
necesitamos que la carpeta del proyecto sea un repositorio cubierto por git

Git funciona mediante una terminal de comandos, para introducir las instrucciones
de las operaciones a realizar con los archivos de nuetros proyectos

Para usar los comandos git, podemos hacerlo desde la consola git bash, o desde vs code que tiene git integrado
Con vs code, se trabaja con la terminal, en la ruta de la carpeta de trabajo

Con git bash debemos ubicarnos en la ruta de la carpeta del proyecto,
o abrir git bash dentro de la carpeta, haciendo click, git bash here
registrase en git
// git config --global user.email "francoio04@hotmail.com"

Una vez en la carpeta, para cubrir el proyecto con git, el comando es
// git init (en la ruta del proyecto)
crea repositorio, proyecto cubierto por git
solo se ejecuta una vez, al comenzar
creado el repositorio git puede detectar cuando un archivo sufre cambios o vuelve a su estado original
al crearse el repositorio internamente se crean dos áreas, donde irá almacenando los archivos

-staging area
donde se almacenan los archivos de forma temporal,
podemos ver qué archivos tienen seguimiento por git, en qué estado se encuentran, etc
es un area de preparacion, a donde se llevan los archivos para luego poder guardar las versiones del proyecto
con los cambios en los archivos

-repositorio local
donde se almacenan esos respaldos que git toma, y desde donde las podemos rescatar cuando queramos
es donde están guardadas las versiones que hacemos del proyecto

alternativa al comando git init,
desde el menu git de vs code, inicializar repositorio

al crear repositorio, estamos en master

    Seguimiento
Es decir qué archivos llevar al staging area
Una vez cubierto el proyecto, contando con las areas, podemos decirle a git que de seguimiento 
a archivo/s, de carpetas, o a todos del proyecto entero

// git add archivo/ruta
para especificos

// git add .
para todo, del repositorio en que nos encontramos
si se hace seguimiento de todo el proyecto, lleva todos los archivos al staging area
al hacer luego status ya podemos ver los archivos, que estaban dentro de carpetas

    Quitar de staging area
// git rm --cached ruta/archivo

// .gitignore
archivo en el proyecto, determina cuales ciertos archivos ignorar

    Guardar versiones
Una vez que los archivos están en el staging area, para guardar esta version del proyecto
// git commit -m "descripcion"
Traslada los archivos del staging area, guarda la version en el área del respositorio local,
desde esta área podemos recuperarla en cualquier momento y restaurar el proyecto
a cómo se encontraban los archivos al momento de ese commit

*Practica*
Creamos nuestro proyecto con sus archivos y carpetas
- git init
cubrimos el proyecto, se crea el repositorio

// git status -s
da un listado con todos los archivos de la carpeta del proyecto y su estado

?? sin seguimiento

rojo: no están en el staging area
verde: en el staging area

A: add / modificado, add
M roja: commit, modificado
AM: staging, modificado

luego de commit
M verde: modificado y luego preparado, listo para commit
MM: preparado luego de modificacion, pero volvio a modificarse

modificado solo aparece si el archivo esta en staging o repositorio

- git add index.html
- git status -s

- git commit -m "inicio"
commit lleva al respaldo lo que haya y como esté en staging en ese momento
luego de hacer el commit, si usamos el comando status no aparece lo que se llevó al repositorio

todo lo que se agregue al repositorio, y tenga una copia de respaldo desaparece del listado
con status solo tenemos los que no están en el repositorio, informando si estan o no en staging

si un archivo del sufre modificacion, aparece el estado
avisa que ese cambio no ha sido respaldado, aparece si no tiene seguimiento

para poder guardar en repositorio, se debe llevar primero al staging area, cada vez
le decis que ese archivo tiene la ultima version, y luego haces el commit, se prepara

    Ver commits
// git log --oneline
versiones

    Restaurar proyecto a una version
guardamos una segunda version del archivo index.html
restauramos como al prinicipio, al primer commit

// git reset --hard codigo_commit
restaura el proyecto, todo lo que haya en dicho commit

luego de restaurarlo, con status vemos que el archivo no está en el listado,
porque se encuentra en el área de repositorio local
y al ver los commit, al restaurar a una version anterior, perdemos las mas recientes
que vinieron despues

    Add y Commit a la vez
luego de realizar cambios en los archivos
// git commit -am "descripcion"

es para los que hayan pasado por staging y/o commit y luego han sido modificados
los vuelve a preparar para hacer el commit y lo ejecuta

cuando ya el commit del proyecto está guardado, status aparece vacio
ya han pasado por staging y commit
no necesitan volver a add
estos archivos pueden volver a tratarse cuando vuelven a sufrir modificaciones
como ya estan el area de commits, se puede usar el comando -am

si aun no han tenido seguimiento, debe agregarse a staging primero .
y luego tratarlo 

    Cambiar descripcion de un commit hecho
Se usa el editor vim, un editor dentro de la consola de git, que permite modificar cosas,
como por ejemplo esto, para abrir el editor, en este caso, podemos usar el comando
// git commit --amend
al abrirse el editor, escribimos el comando :i
entonces podemos empezar a editar, al pusar cualquier tecla,
por ejemplo suprimir, ya tenemos en la zona superior el cursor
suprimimos para borrar esa descripcion, luego pulsamos esc, sale del editor
para escribir la nueva descripcion, de nuevo :i
para comenzar a escribir, aparece abajo, luego de terminar damos enter, damos esc
y ya aparece arriba la nueva descripcion
:wq para guardar y salir del editor
**

---
Gh y comandos:

    GitHub
Servicio de nube para el alojamiento de repositorios git
Una opción gratuita, ilimitada, muy potente

Subir repositorio a github, asi tener un respaldo remoto
Ir a la pagina de github, crearse una cuenta, boton create repository
al crearlo, nos dice si vamos a crear un repositorio desde la linea de comando
o vamos a subir un repositorio existente desde la linea de comando
porque en github se puede crear incluso un proyecto desde 0 directamente en github
o importar a este repositorio que creamos, el codigo de otro repositorio
que podamos tener en github, o en otros sistemas

en este caso vamos a copiar un repositorio existente en local
usamos el codigo de la segunda opcion
repositorio local, debe tener commit

// git remote add origin https://github.com/iovannif/git.git asocia
// git push -u origin master
version remota de nuestro repo, una copia

si es la primera vez, github pide la cuenta, token
https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/
https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token#using-a-token-on-the-command-line
token 
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

actualizar la pagina del repositorio, para ver que subio
solo pone lo que está en el repositorio local, los commits
en que commit está cada archivo,
se puede ver cada commit, como está el proyecto en cada version, los archivos
y al hacer git log --oneline, te muestra qué commit está tambien en origin

para ir subiendo las modificaciones
git push -u origin master

si algo le pasa a nuestro proyecto en local, siempre podemos recuperarlo de la nube

    Editar desde github
Modificaciones hechas en remoto, trasladarlas o sincronizarlas a local
Para escribir codigo desde github, entramos al archivo le damos editar
Esto es util cuando ves el proyecto en github y te das cuenta que hay cosas por retocar
Es el proceso inverso, esa pequeña modificacion haces en github y luego sincronizas
con lo que tenes en local
En la parte inferior de la edición, tenemos la opcion de commit changes
Hay dos opciones, commit directo al master, o crear una rama para este commit
De momento, usamos la primera, por defecto
Con esto ya estan guardados los cambios en remoto
asi por cada archivo, haces commits

Para traer esas modifaciones del remoto, al local
local a remoto: push / subir
remoto a local: pull / estirar

// git pull
cuando ya sabe, a que local está asociado
detecta los cambios realizados en remoto
modifica los archivos del repo
aparecen que archivos fueron modificados
en git log --oneline aparece un commit como un update, origin, a qué afecto ese commit
en el repo github tambien, los archivos

para el proceso inverso
// git push
cuando ya lo usaste anteriormente, para otro repo gihub, cambiar primero
desde github hace el commit directo
desde local, si solo haces el cambio y queres hacer el push asi
dice que no hay nada para actualizar, everythig up-to-date
es lo mismo, hacer commit local y push
luego en git log --oneline, te dice que el commit ya está en ambos

el commit guarda el proyecto como está, una version, en el tiempo, los archivos
gracias a los commits, versiones del proyecto, se puede volver, los archivos

en github podes ver tu proyecto
ver que commit tiene cada archivo, cual le afectó
en cual se le incluyó, si no fue de todo el proyecto
si a un archivo no le afectó el ultimo, dice cual fue el que le afectó

van apareciendo branches mientras avanzamos
git fetch tambien trabaja con las branches
parecida a git pull

    Tags
Si al punto en el que estamos, queremos guardar una primera version del proyecto
Consideramos que funciona y está habilitado para decir que es la version 1.0
Es susceptible de que, en el futuro le pondamos agregar mejoras y funcionalidades
Pero de momento, podria estar acabado
Para decirle a git que el proyecto está acabado, que es la version 1.0
que todos los miembros del grupo de trabajo, incluso cualquier otro desarollador
si el repo es publico, se pueda descargar la primera version como tal
se usan las tags, que nos permiten especificar versiones de nuestro proyecto,
como cualquier software
en github, nuestro repo, tiene la pestaña de tags
de momento no hay realeases

Crear tag
// git 05-02-20v1 -m "proyecto 1 version 1.0"
le hemos dicho que tenemos ya una version del proyecto, en local
git log --oneline para ver
nos muestra que el ultimo commit tiene un tag, aparece con el nombre del tag
en la lista de commits, el primero es el ultimo, head
para subir tag a origin
// git push --tags 

cuando aparecen los tags en github, dan la opcion de descargar el proyecto, comprimido
podes descargar dicha version del proyecto, en un zip para windows, tar.gaz para linux
para descargar el proyecto como lo tenemos en cierta version le damos
los tags son el proyecto subido, para poder descargarlo como tal, no se puede ver
del repo, te bajas los archivos
es solo el proyecto como tal, la carpeta con sus archivos, no es un repositorio como tal, no es git

bajamos, tenemos el proyecto, tal como está en github, 
en el repo remoto, origin, lo que haya en el commit, lo que subimos
no necesariamente el proyecto local, como hayamos cubierto, por ej
en este ejemplo, no habiamos incluido todos los archivos, seguimos algunos e hicimos los commits
estará de acuerdo a como hayamos hecho, por eso el proyecto que bajamos no está completo

cualquier persona, de un grupo de trabajo, o fuera, si puede acceder aqui a github, si es publico
puede bajarselo, como está en ese momento   
al ir haciendo versiones del software, subimos y estarán en github
vamos dejando una fotografia, de cada version del proyecto, para que cada persona
pueda bajarse cada version del proyecto, la que estime oportuna
incluso, si una version no funciona bien, podemos volver a la anterior, tambien desde aqui
con las tags

gracias a esto, si le sucede algo a nuestro proyecto en local, lo podemos recuperarlo
como tenemos el repo origin

en el apartado repositorios de github, vemos como tenemos cada proyecto actualmente
de acuerdo a los commits que vamos haciendo, y subiendo

    Clonación
Clonamos repositorio de remoto a local
desde el repo de github, tenemos como opción el boton de code
que tiene varias opciones, clonar con https o url, clonamos desde consola

abrimos git bash en la ruta donde queremos clonar este proyecto
// git clone https://github.com/iovannif/git.git
ruta del repo github

Si le pasa algo a nuestro proyecto local, haciendo una clonacion, desde github nos lo podemos llevar

para simular la perdida, debemos cerrar los programas que estan trabajando con el proyecto
ej vs code, git bush, para poder eliminar la carpeta
y clonamos, volvemos a tener la carpeta de ese proyecto

al decirle clone, git detecta si hay otra carpeta con el mismo nombre
del repo, y si no está vacia para usar

//git clone repo_remoto nombre
da nombre a la carpeta
sin el, le pone el mismo nombre que el remoto

este si es un repo, viene con .git
vimos como subir uno, y bajar, clonarlo de remoto a local

    Ramas
A cada flujo de trabajo se le da un nombre
Hasta ahora hemos trabajado con una sola rama, la que git crea por defecto, y su copia remota
La rama default de git se llama master, se puede cambiarle el nombre, pero se acostumbra a llamarla asi
Mientras trabajamos con git, en consola nos avisa en que repositorio y rama estamos
Ademas de la rama master, podemos crear otras

Se pueden crear ramificaciones, del flujo principal, son lineas paralelas de trabajo independientes
Es como si creas una copia o duplicas la rama principal y podes trabajar por separado, esto trae ventajas
Esta otra rama puede ser creada para diferentes propositos

Durante la vida de desarrollo de un software complejo es comun
modificar, volver hacia atras, tocar, hacer commits, volver adelante, hacer pruebas
Las ramas permiten realizar pruebas, al hacer commits poder volver atras de forma sencilla
Experimentar en la rama secundaria, sin afectar a la principal
Si las cosas no van bien en la secunadria, eliminar la rama

Al trabajar solo, tambien al ramificar, se puede trabajar a la vez en ambas, 
ir cambiando de ramas y hacer commits en las dos
Esto no es obligatorio, pero es una opcion trabajar en ambas paralelamente

En proyectos complejos, en grupos de trabajo normalmente el trabajo se divide
Cada persona se encarga de una parte diferente del trabajo, cada cual con su rama
Y cuando se ha comprobado que el software funciona bien en las ramas
llega el momento de fusionarlas en una, con los cambios hechos en cada parte
en un proceso llamado merge

En teoria el merge debe ser sencillo, lo ideal es que cada persona se dedique a una parte diferente, 
de archivos distintos, pero puede pasar que en mas de una rama se este modificando el mismo archivo,
la misma parte, ej la misma linea, es aca cuando git avisa que hay un conflicto de concurrencias
en el merge y pregunta que hacer

Las ramificacion es una caracteristica muy util de git
con otros sistemas de control de versiones trabajar con ramas es muy complejo, 
pero con git es sencillo

*Practica branch*
Siguiendo con nuestro proyecto de practica, git log --oneline
el ultimo commit indica a qué ramas afecta,
lo que se hizo, qué incluyó ese commit, 
ej: head -> master, tag, origin/master
head indica la rama principal
origin/repo, es el origin del repo

    Creamos una rama
// git branch nombre_rama
para realizar pruebas en un archivo, damos un nombre identificativo
al ver los commits, ahora aparece una nueva rama, junto al flujo de trabajo master

    Ver ramas del proyecto
// git brach
la lista nos muestra en que rama estamos

    Moverse a rama
// git checkout nombre_rama
si tiene origin, te dice como van de sincronizacion
si una va diferente a la otra respecto a commits

dejamos la rama master tal como la tenemos, git branch, 
git log --oneline muestra los commits de la rama
los primeros commits, los anteriores son iguales a la rama principal
porque es una copia, pero a partir de la ramificacion puede variar
por ej al estar en una rama, de acuerdo a los cambios y commits hechos
en el listado aparecen los hechos en esta rama, y no los de la otra rama
estamos trabajando en el mismo proyecto, mismo archivo
pero en hilos distintos de trabajo, es como si se estuviese trabajando
en dos proyectos paralelos distintos

Modificaciones y ramas
Nuestros archivos son unicos desde el editor, pero el contenido puede cambiar
depende de en qué rama estemos, de acuerdo a qué cambios hayamos hecho
por ejemplo, estando en una rama, el contenido del mismo archivo puede cambiar
al pasar a otra rama y estar trabajando con los mismos archivos
es decir, para nosotros fisicamente es un mismo archivo, pero git internamente
tiene varias copias del mismo, de acuerdo a las ramas

ahora que estamos en la otra rama, en la rama prueba
de momento la copia es exacta, aun no hemos tocado los archivos, 
estan como cuando creamos esta rama, empezamos a modificar los archivos de la rama prueba
luego de los cambios, hacemos add y commit, estamos desde la rama secundaria

comparamos, hemos hecho cambios en una rama, pero la otra sigue intacta, el mismo archivo
debe ser diferente en contenido, para cada rama
hechos los cambios, al movernos de rama, desde el editor vemos la diferencia
por los cambios hechos desde otra rama
estamos en ramas distintas

aunque estemos en dos ramas, son del mismo repo
las acciones, por ej de estado, add, etc afecta al repo

como tenemos actualmente los archivos, es del ultimo commit
un commit puede incluir varias ramas, ej origin/master, origin/prueba
commits versiones parciales, tags commit final

    Merge
Una vez que el codigo funciona y estamos satisfechos con lo que hemos hecho en la rama
secundaria, debemos unirla con la prinical, fusionamos los cambios con lo que teniamos anteriormente
en la rama principal
o si hemos hecho cambios en ambas ramas, por ejemplo en un grupo de trabajo
cuando trabajan en distintas partes del proyecto

Para hacer un merge, primer paso, obligatoriamente estar en la rama principal
el merge se debe hacer desde la rama original
// git merge rama_secundaria
fusionamos la segunda rama a la principal

luego del merge, git log --oneline
muestra que el ultimo commit de la otra rama, afecta a la principal,
por la fusion de ramas, y dice el nombre, qué commit fue
si sale que el commit es de otra rama a la que estamos, se hizo merge

tambien, el cambio puede ser, desde rama secundaria, borrar lo que se ha hecho
en al principal, y al hacer el merge se queda esto, se guarda el borrado

    Borrar rama
// git branch -d nombre_rama
confirmar // git branch -D nombre_rama
luego de eliminarla, git branch,
git log -online, vemos que el commit se conserva

Conflicto
Si en ambas ramas se ha modificado el mismo archivo y hecho commit, git intenta hacer el merge,
detecta el conflicto y avisa, dice que soluciones y hagas commit
a pesar de esto, hizo el merge pero defectuoso
vemos en el codigo modificado desde ambas ramas, que en efecto tiene los cambios de ambos
los hechos en la rama principal head>> --- y los hechos en la rama secundaria prueba>>

Mientras que el conflicto está si resolver, la consola de git bash
en el titulo de directorio repo, rama, indica que está en merging
        
---
Trabajando desde terminal vsc:

    VS Code
Desde VS Code, trabajar con ramas, y cuando hay conflictos, es mas sencillo de gestionar
VS code incluye un conjunto de herramientas que facilita el trabajo con git y github
Creamos un nuevo proyecto para trabajar con git desde la terminal de vs code        

Al hacer un merge, si desde varias ramas se toca el mismo archivo
no hay problema si sean en distintas partes, las fusiona
pero hay conflicto en el cuando ambas modificaciones ocurren en la misma linea
por ejemplo, en el mismo el elemento, en un parrafo cambia el texto

Cuando hay conflicto en el merge, vsc te da opciones de qué hacer para solucionarlo
Te muestra el archivo marcando los cambios por las ramas, marcando qué codigo es de cada cual
Current change, es como está actualmente, el ultimo commit hecho, desde la rama principal, head
Incoming change, es el cambio que se está intentando agregar, desde la rama secundaria

Tenemos las opciones de aceptar uno u otro, de aceptar ambos, y de comparar, para el merge
En la vista de comparacion, nos muestra los archivos lado a lado, vemos qué hay en cada uno,
y la diferencia en el contenido, de la linea
Mientras haya este conflicto, en la barra de navegacion de vsc, en el archivo marca C de conflicto
y ! en la rama, una vez que se soluciona y se hace el commit, desaparecen

---
Trabajando desde interfaz de vsc:

Herramientas
Gracias a las herramientas que ofrece vs code, podemos incluso prescindir de la consola
agiliza las operaciones, ahorra tiempo, simplifica pasos

Tenemos la barra inferior de vsc, donde al estar trabajando en un repositorio git
Muestra la rama en la que estamos, con un * si hay cambios por guardar, commit, ! conficto
Origin, sincronizar: push/pull, cuántos por delante, subir repo a gihub, crea directo
En github, el repo, el tiulo muestra cual es el commit actual

El icono branch, de git, donde marca las tareas pendientes de git, cambios por guardar, commit
Tenemos el icono de commit directo, sin pasar por staging, cuadro para ingresar descripcion, ctrl+enter
Tres puntos, operaciones, las tareas que hemos hecho con comandos, hacemos con click
                
Crear una rama en vs code, hay varias formas,
desde el menu de las herramientas de git, y desde la barra inferior de vs code
menu arriba, cuadro para buscar crear, moverse, lista de branches

    Github y VSC interfaz, sincronizados
Subir un proyecto desde vscode a github y sincronizarlo desde vsc
Comenzamos un nuevo proyecto, para ver como se comienza un proyecto desde cero con github, y vsc
En github creamos un repo nuevo, nos fijamos en la url de este repo

Clonamos, cuando no hay git, origin/master based
En vsc, en el menu de arriba, command palette, git clone: clone from github, url, repo.git
Trabajamos desde el editor, creamos archivos, !html vsc default emmet, beautify ayuda a escribir html

Hacemos un commit, para subir a github lo que tenemos en local
Menu git en vsc, tres puntos, push
Ya está vinculado, al haberse traido de remoto a local
Se sube y vscode pregunta si hacer git fetch periodicamente
Se pueden hacer muchisimas cosas en github, esto es para inciar un proyecto,
para subir, un push en vsc

Una vez que tenemos archivos tanto en github como vsc,
podemos modificar archivos desde github, hacemos commit desde github
al hacer commits de un lado, y/o del otro, en vsc sale la opcion de sincronizarlos
hace el push y pull correspondiente, para tener el repo igual en local y github

Hacemos el proceso inverso:
Commit vsc y push, y ya sale la opcion de sincronizar cambios, vsc git avisa cada cosa
cuando estan a la par, no aparcen numeros de subida o bajada junto al icono de sync,
se actualiza el repo al ultimo commit, los archivos, el contenido, en github
y podemos ver cada commit

    Ramas en github y VSC
Como crear una rama, como modificar, incluir archivos en esa rama nueva,
y como hacer un merge, en github de varias ramas
una vez hecho el merge en github, como sincronizar toda esa tarea en vsc,

En github, trabajamos con el proyecto que habiamos sincronizado
al entrar al repo, arriba tenemos unas opciones, entre ellas, branch y nos indica cuantas tenemos
en este caso 1, clickamos el menu, y vemos las ramas, tenemos una rama, master
esto pasa porque lo sincronizamos desde vsc, entonces le da ese nombre

el nombre que se le da en vsc, es el que adopta github
si creas el proyecto desde 0, los archivos en github, por defecto llama a la rama main
pero como este esta sincronizado desde local, es el nombre que le dió, de local

junto a la rama, en la lista, vemos por quién fue modificado por ultima vez,
sale el usuario de git local, franco

volviendo al repo, a la izquierda, junto a la opcion de las ramas que tenemos,
la opcion de la rama actual, sale el nombre, y es un menu desplegable, le damos
y es un pequeño menu de las ramas, tenemos la opcion de encontrar o crear una rama
buscar, movernos entre ramas

creamos una nueva rama
creamos la rama secundaria, desde github
escribimos en el cuadro el nombre, y damos en crear rama de master
nos mueve a ella, vemos en el pequeño menu, en la lista, que el master siempre es el default

desde github, estando en esta rama secundaria, damos en add file
creamos un nuevo archivo, escribimos el nombre con la extension
para que tome efecto, damos en commit new file
tenemos la opcion de crear una nueva rama para hacer commit, y hacer un pull request:merge

en la rama, remo, github nos muestra un mensaje avisando que la rama está a un commit
por delante de la rama principal, aqui tenemos un boton de pull request, otro de compare
para comparar que se ha hecho en una rama y en la otra
desde aqui mismo podriamos hacer un merge

volvemos atras, github por defecto nos lleva a master
vamos a la secundaria, un pull request es una peticion de pull
en github tambien podemos trabajar en forma simultanea con otras personas
si esas personas quieren hacer un merge con el master, se supone que deben hacer una peticion
no deberia poder hacer el merge de su rama sin pedir permiso

para hacer un merge de nuestra rama, compare & pull request
solicitamos, create pull request, al hacer esto, github analiza
para ver si no hay conflictos, qué tiene que integrar, etc
y avisa si la rama tiene o no conflictos, con la rama base, default
entonces, al ver que no hay conflictos, hemos recibido la peticion,
confirmamos, marge pull request, nos informa que rama es, confirm merge
y lo hace

hemos visto anteriormente cuando trabajabamos que se puede hacer sin borrar la rama secundaria
se supone que si se hace un merge, la rama de la que viene el merge, ya no la necesitas
porque todos los cambios que habian en esa rama, se ha llevado a la principal
por esto, despues de hacer el merge, nos ofrece el boton delete branch
por que normalmente es lo que se hace
borramos la rama y vemos que tenemos la opcion de restore branch por si nos arrepentimos
vemos que se ha hecho merge del commit de la secundaria a la master, da opcion de revert
vamos al repo gh, y vemos los cambios, se ha agregado el css que no teniamos

vamos a vsc, donde tenemos sincronizado el repo local con el github
damos en sincronizar, traemos los cambios hechos en remoto, hace el push pull
vemos que tenemos el css en local

    VARIAS RAMAS

    Github Fork
    Ramificaciones de proyecti y colaboraciones
    Es una ramificacion del proyecto, que se utiliza no solo pero casi siempre
    para colaborar con el proyecto original
    No es una branch como vimos antes
    Un fork es una ramificacion de todo el proyecto, desde el principio hasta el final

    Ejemplo, un programador que tiene un repo en github
    con un proyecto que tiene, que ha ido elaborando a lo largo del tiempo
    y ahi está, ademas ese repositorio, el programador lo puso publico
    para que todo el mundo lo pueda ver, y aquel que lo desee lo pueda clonar
    en su equipo local y pueda utilizarlo por ej como base de otros proyectos

    Tenemos al otro programador, que echando un vistazo a ese repo publico
    lo ve muy interesante, tiene 2 alternativas, hace un clon, lo clona
    lo bajaria a ese proyecto a su equipo local, y ahi haria las modificaciones
    y luego lo subiria a su repo, a su propio github
    o bien hacer un fork, que es parecido a hacer una clonacion, pero con algunas
    ventajas adicionales

    Hace el fork, se crea una copia exacta de ese repositorio
    en github, al hacer el fork, automaticamete tiene un repositorio en su cuenta
    que es la copia del proyecto original, al que le hizo fork
    no en local, sino en github
    una vez que tiene el repo nuevo con una copia del proyecto
    lo suyo es que clone su proyecto y se lo baje a su ordenador local
    para trabajarlo con su ide, y modifique lo que quiera
    las utilidades que esto puede tener son muchas

    podes utilizar como base este proyceto para otro que quieras ha cer
    si vas a elaborar un proyecto complejo, y gran parte de el está colgado
    en ese repo ne github de forma publica
    haces fork, lo clonas a local, y tenes gran parte de trabajo hecho
    lo que queda, es agregar tu parte, apra culminar el preoycto

    Esa es una alternativa, usarlo como base de otros proyectos
    otra muy interesante, que ofrece el fork, es poder colaborar con otros
    programadores, ves un proyecto publico muy interesante, y ves que
    podes agregarle cosas buenas a ese proyecto, cosas que hacen que el proyecto
    sea mas potente, mas versatil, que funcione mejor
    corregir pequeños errores, es ahi donde mas se utiliza fork, en esos casos
    a la hora de contribuir con proyctos que puedas ver colgados pori

    una vez que el otro programador tiene el repo, copiado de si mismo
    y hace sus modificaciones, programa, va añadiendo caracteristicas nuevas
    y un vez, hecho, hace el commit, sicroniza su repo local con si github
    y y tiene ese commit en su remoto
    y es en este momento donde entra la gran ventaja del fork
    una vez que tenes en tu repo los commits que hayas ido agregando con las
    modificaciones pertinentes podes realizar un pull request

    un pull request es una peticion o sugerencia al programador original del proyecto
    para que pueda ver qué modificacion has hecho, es ofrecerle
    que mire las modificaciones que hiciste a su proyecto, en tu repo
    esta es una ventaja del fork
    de forma que esta herramienta permite colaborar en equipo
    de una forma muy potente 

    antes de la existencia del fork, para poder hacer este tipo de cosas
    se podian hacer tambien, pero habia que darle mas vueltas al manejo de git y de github
    con fork es muy sencillo, simplemente con hacer un pull request
    el programador original ya recibe la peticion y puede mirarlo, sin que, de momento
    su proyecto sea alterado para nada, puede ver qué es lo que ha hecho ese otro programador
    que le está ofreciendo, aca hay 2 opciones, al programador original
    puede ser que esas novedades, esas modificaciones no le gusten, si no le gusta
    lo rechaza, y el proyecto queda como estaba, no importa lo que el otro hay eso en su copia
    la otra opcion es que al ofrerle ese commit, con las modificaciones, al programador original
    le guste y lo acepte, si le parece muy interesante, y esas modificaciones realmente mejoran
    mucho el proyecto, lo hacen mas potente, mas versatil, entonces acepta esa peticion, ahi
    se produce un merge entre el repo original y el de la peticion, el proyecto fork del github
    del otro programador, el proyecto original, adquiere esas modificaciones con los commits que haya
    ofrecido el otro, se modifica

    es una caraceteristica muy potente de github, mientras que el otro programador esta trabajando
    con el proyecto al que ha hecho fork, el original está intacto, y nunca se alterará mientras no
    se acepte el pull request, aceptemos lo cambios que nos proponen, y puede ser que no nos propongan
    nunca nada, que lo utilicen simplemente como base de sus propios proyectos, y nosotros no veamos
    nunca un pull request por parte de la comunidad, de nadie,
    este ejempl con dos programadores, se puede trasladar a muchos
    si tenes un repo publico en github, lo ven cientos y miles de personas, y esos programadores
    uno tras otro, van ofreciendo sus cambios, su aporte al software, sus mejoras dia a dia

    lo que puede ser un proyecto regular, sencillo al principio,
    gracias al trabajo conjunto, de todos esos programadores,
    esos cientos de programadores, que me van mandando pull request,
    todos los dias, y yo echo un vistazo y acepto
    mi proyecto va creciendo, y se va haciendo cada vez muy potente,
    es asi como se han creado proyecctos muy potentes, de codigo libre,
    algunos de ellos muy famosos

    como se hace
    Creamos una segunda cuenta de github, para hacer un fork
    son dos personas diferentes, la segunda va navegando por github
    encuentra a un programador con un repo, ves los archivos, el proyecto, tal,
    ves que ha hecho, los tags, para ver las fechas, en fin,
    te gusta, y dedicis colaborar, para agregar modificaciones,
    entonces hacemos un fork, cuando estamos viendo un repositorio en un perfil
    publico de otro usuario, hay una opcion fork, y vemos la cantidad, cuantos fork
    tiene este proyecto, pulsamos y automaticamente, comienza una copia del repo,
    a mi perfil, ahora encontraremos que tenemos el repo, y en fork, dice la cantidad
    te sale de quien es el proyecto original, lleva  el mismo nombre, y dice que es un fork
    de un proyecto ajeno, ambos programadores ven cuantos fork tiene el repo
    el dueño ve cuantas personas estan siguiendo o modificando, su copia de ese proyecto

    una vez que el segundo programador tiene el repo en su perfil,
    lo clona a local, desde el boton de code, del repo, copiamos la url
    y hacemos la clonacion, es parecido a una clonacion directa de un repo ajeno
    y empezamos a hacer nuestras modificaciones, podemos empezar por arreglar los fallos
    que tenga el proyecto original, hacemos el commit, con una descripcion que haga saber
    bien que se ha hecho
    sincronizamos, para esto, como estamos vinculados con el otro perfil de github,
    da error, para poder trabajar con un perfil diferente, tenemos que borrar las credenciales,
    al subir cosas de local al github, en windows se crean unas credenciales,
    al intentar subir ahora, desde el mismo equipo a otro perfil, da error,
    vamos a borrar las credenciales que tenemos de antes, vamos a configuracion, de windows,
    cuentas, en el buscador, credenciales, adminsitrador de credenciales, credenciales de windows
    en esta lista, aparce la de credenciales de github, desplegamos la opcion, y damos en quitar
    una vez hecho esto, podemos trabajar con la otra cuenta, la vinculacion, sabe con
    que repo de que cuenta estamos sincronizando, debido a la clonacion por url
    hacemos el push con terminal, para vincular primero, con remoto
    //git push origin, nos autenticamos a github, token    
    
        token perfil 2
        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                

    linkamos repo remoto, para hacer push
    git remote add origin https://github.com/iovanni2/git
    ya existe por que se trajo primero de ahi, antes primero ibamos de local a remoto,
    por eso se hacia primero en local la referencia
    borramos la credencial, para que al hacer el comando push, abra el form de github para vincular
    a cuenta

    en mi perfil, me sale que mi repo es de otra cuenta, fuente
    porque me logee despues con esa otra, en esa conexion entre git local y github

    para hacer cosas relacionadas a github, desde vsc, la extension
    dice te ahce vincular a una cuenta

    es ahi cuando se quedan las credenciales
    te salen los repos de esa cuenta

    para hacer un push, te pide logearte a github

    subir/clonar
    uno es la extension de github para vsc, el largoº
    el otro es el log de github, el corto





**

-commit: partidas, un save del proyecto de cierto momento, el contenido
del proyecto se actualiza cada vez al ultimo commit
es como guardar los cambios
-estas en una rama

-practicar con varias ramas, merge, causar conflicto
4, 5 ramas, cada una con cambios diferentes, aprendemos
como funciona realmente el merge
como pasa en gh, complicamos,
fork

-commit atras, volver adelante, ir moviendose
-rever merge, revert commit
-codigo commit

+git clone, git acepta, no necesitas
+radme: descripcion para que la gente entienda el proyecto
+gitub repo, si el commit es de un merge, pullr request aparece
+tambien se puede clonar por ruta, ademas de 
+al clonar es un repo, ya viene con seguimiento de git
+credenciales es de gihtub, no de git local, ya se queda asiç
+si creas primero, para subir, configuras
+si clonaste, ya esta vinculado, haces push directo
+creas en remoto, en local referencias
+git remote remove [name of the remote]
+comando clone clona directo, para clonar con vsc necesita que github acceda
+si esta abierta la sesion de github, la vincula, sino sale un form en el navegador
+se queda vinculado con la cuenta, para cambiar se quita las credenciales, restart vs code
+para push vsc, configurar con remoto
+ -u setup
+ si no le indicas la rama al push, crea master
+ eliminar una de remoto: git push main --delete master // repo_remoto rama 
+pull ya se puede hacer una vez vinculado
+se puede restore rama en github
+lo que hace es otra rama, con el nombre del local, sube a una rama con el mismo nombre

____________________________________________________________________________
git config --global user.email "francoio04@hotmail.com" - registrarse a git
git config --global user.name "franco"

git init (en carpeta del proyecto) - repositorio git
git status -s - estado de los archivos del proyecto
git add ruta/archivo - archivos especificos a staging area
git add . - todos los archivos del proyecto  al staging area 
git rm --cached ruta/archivo - quita de staging
git commit -m "despcripcion" - guarda la version del proyecto, con sus archivos

git log --oneline - lista de versiones
git reset --hard codigo_commit - vuelve el proyecto a una version anterior especificada
git commit -am "descripcion" - despues de modificar, add y commit luego de staging/commit
git commit --amend - cambiar descripcion de commit
vim - :i, supr, esc, :i, escribimos, enter, esc, :wq
rm -fr .git - borra repositorio

git remote add nombre ruta - copiar repositorio en nube
git push -u nombre master - cargar primera vez
git push - cargar de repo
git push nombre
git pull - trae los cambios hechos en remoto
git pull link

git tag nombre_etiqueta -m "descripcion" - tag indica una version terminada del software
git push --tags - subir tags a remoto
git clone repo_remoto *nombre - clona en local el proyecto

git branch nombre - crea una rama
git branch - listado de ramas en un repo
git checkout nombre_rama - moverse a rama
git merge nombre_rama - fusiona la rama a la principal

git d- nombre_branch - elimina rama
git D- nombre_rama - confirma eliminacion de branch